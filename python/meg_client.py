"""
meg_client.py â€” Client Python pour la communication avec un Arduino dans le cadre dâ€™expÃ©riences MEG (gestion de triggers et boutons rÃ©ponse).

====================================================================================
Objectif
------------------------------------------------------------------------------------
Ce module fournit une interface haut-niveau pour dialoguer avec un microcontrÃ´leur Arduino
connectÃ© Ã  un systÃ¨me MEG. Il permet :
    - dâ€™envoyer des triggers TTL (pulses numÃ©riques) sur des lignes prÃ©cises
    - de fixer des lignes Ã  HIGH ou LOW de maniÃ¨re persistante
    - de lire lâ€™Ã©tat des boutons rÃ©ponse (boÃ®tier FORP, par ex.)

====================================================================================
Protocole de communication sÃ©rie
------------------------------------------------------------------------------------
- Communication via port sÃ©rie (USB)
- Encodage binaire : chaque commande commence par un opcode (entier 0â€“255)
- Les arguments Ã©ventuels suivent sous forme dâ€™octets supplÃ©mentaires (bytes([...]))
- Toutes les valeurs sont des entiers non signÃ©s entre 0 et 255 (ou 0â€“65535 pour les durÃ©es)

Commandes disponibles (opcodes dÃ©cimaux) :
  10 : set_trigger_duration   [2 octets : durÃ©e en ms, entier 0â€“65535]
  11 : send_trigger_mask      [1 octet : mask 0â€“255]
  12 : send_trigger_on_line   [1 octet : numÃ©ro de ligne 0â€“7]
  13 : set_high_mask          [1 octet : mask 0â€“255]
  14 : set_low_mask           [1 octet : mask 0â€“255]
  15 : set_high_on_line       [1 octet : numÃ©ro de ligne 0â€“7]
  16 : set_low_on_line        [1 octet : numÃ©ro de ligne 0â€“7]
  20 : get_response_button_mask -> Arduino renvoie 1 octet (mask 0â€“255)
====================================================================================

Exemple minimal :
------------------------------------------------------------------------------------
from meg_client import MegClient

with MegClient('/dev/ttyACM0') as dev:
    dev.set_trigger_duration(5)          # dÃ©finit la largeur du trigger Ã  5 ms
    dev.send_trigger_on_line(3)          # gÃ©nÃ¨re un trigger sur la ligne 3
    mask = dev.get_response_button_mask() # lit les boutons appuyÃ©s
    print(mask, dev.decode_forp(mask))
====================================================================================
"""

import serial
import struct
from typing import List, Dict

# --- Constantes par dÃ©faut ---
DEFAULT_BAUD = 115200      # vitesse de communication sÃ©rie (doit correspondre Ã  celle de lâ€™Arduino)
DEFAULT_TIMEOUT = 0.2      # dÃ©lai max en s pour lire une rÃ©ponse avant timeout

# --- OpCodes correspondant aux commandes Arduino ---
OP_SET_TRIGGER_DURATION   = 10
OP_SEND_TRIGGER_MASK      = 11
OP_SEND_TRIGGER_ON_LINE   = 12
OP_SET_HIGH_MASK          = 13
OP_SET_LOW_MASK           = 14
OP_SET_HIGH_ON_LINE       = 15
OP_SET_LOW_ON_LINE        = 16
OP_GET_RESPONSE_BUTTON    = 20


class MegClient:
    """
    Classe principale pour la communication sÃ©rie avec le microcontrÃ´leur Arduino.

    Chaque mÃ©thode correspond Ã  une commande envoyÃ©e Ã  lâ€™Arduino, selon le protocole dÃ©fini plus haut.

    Exemple dâ€™utilisation :
    -----------------------
    >>> from meg_client import MegClient
    >>> with MegClient('/dev/ttyACM0') as dev:
    ...     dev.set_trigger_duration(5)
    ...     dev.send_trigger_mask(0b00001111)
    ...     mask = dev.get_response_button_mask()
    ...     print(mask, dev.decode_forp(mask))
    """

    def __init__(self, port: str, baud: int = DEFAULT_BAUD, timeout: float = DEFAULT_TIMEOUT):
        """
        Initialise la connexion sÃ©rie (sans encore lâ€™ouvrir).

        Arguments :
        - port : chemin du port sÃ©rie (ex. '/dev/ttyACM0' sous Linux, 'COM3' sous Windows)
        - baud : vitesse de communication (baudrate)
        - timeout : durÃ©e maximale dâ€™attente dâ€™une rÃ©ponse (en secondes)
        """
        self.port = port
        self.baud = baud
        self.timeout = timeout
        self.ser: serial.Serial | None = None

        # Dictionnaire de correspondance entre bits du mask et boutons physiques FORP
        self.forp_map: Dict[int, str] = {
        0: "bouton bleu gauche activÃ©",   # STI007 (out) pin 22
        1: "bouton jaune gauche activÃ©",  # STI008 (out) pin 23
        2: "bouton vert gauche activÃ©",   # STI009 (out) pin 24
        3: "bouton rouge gauche activÃ©",  # STI010 (out) pin 25
        4: "bouton bleu droit activÃ©",    # STI012 (out) pin 26
        5: "bouton jaune droit activÃ©",   # STI013 (out) pin 27
        6: "bouton vert droit activÃ©",    # STI014 (out) pin 28
        7: "bouton rouge droit activÃ©",   # STI015 (out) pin 29
        }

    # --------------------------------------------------------------------------
    # ğŸ”Œ Gestion du port sÃ©rie
    # --------------------------------------------------------------------------

    def open(self):
        """Ouvre la connexion sÃ©rie si elle nâ€™est pas dÃ©jÃ  ouverte."""
        if self.ser and self.ser.is_open:
            return
        self.ser = serial.Serial(self.port, self.baud, timeout=self.timeout)

    def close(self):
        """Ferme proprement la connexion sÃ©rie."""
        if self.ser:
            try:
                self.ser.close()
            finally:
                self.ser = None

    def __enter__(self):
        """Permet lâ€™utilisation avec un contexte 'with MegClient(...) as dev:'"""
        self.open()
        return self

    def __exit__(self, exc_type, exc, tb):
        """Ferme automatiquement la connexion Ã  la fin du bloc with."""
        self.close()

    def _ensure(self):
        """VÃ©rifie quâ€™une connexion sÃ©rie est bien ouverte avant envoi."""
        if not self.ser or not self.ser.is_open:
            raise RuntimeError("Port sÃ©rie non ouvert â€” appelez dev.open() avant dâ€™envoyer des commandes.")

    def _tx(self, data: bytes):
        """Envoie un paquet dâ€™octets sur le port sÃ©rie."""
        self._ensure()
        self.ser.write(data)
        self.ser.flush()  # vide le buffer pour assurer un envoi immÃ©diat

    def _rx_exact(self, n: int) -> bytes:
        """Lit exactement n octets depuis le port sÃ©rie, sinon lÃ¨ve TimeoutError."""
        self._ensure()
        buf = self.ser.read(n)
        if len(buf) != n:
            raise TimeoutError(f"Lecture incomplÃ¨te : attendu {n} octets, reÃ§u {len(buf)}")
        return buf

    # --------------------------------------------------------------------------
    # API â€” Commandes de haut niveau envoyÃ©es Ã  lâ€™Arduino
    # --------------------------------------------------------------------------

    def set_trigger_duration(self, duration_ms: int) -> None:
        """
        DÃ©finit la durÃ©e (en ms) du signal TTL gÃ©nÃ©rÃ© pour chaque trigger.

        Argument :
        - duration_ms : entier entre 0 et 65535 (valeur 5 = 5 ms)

        Exemple :
        >>> dev.set_trigger_duration(5)
        """
        if duration_ms < 0 or duration_ms > 65535:
            raise ValueError("duration_ms doit Ãªtre entre 0 et 65535")
        payload = struct.pack("<BH", OP_SET_TRIGGER_DURATION, duration_ms)
        self._tx(payload)

    def send_trigger_mask(self, mask: int) -> None:
        """
        GÃ©nÃ¨re un trigger sur toutes les lignes dont le bit du mask vaut 1.

        Argument :
        - mask : entier binaire entre 0 et 255 (ex. 0b00001111 active les 4 premiÃ¨res lignes)
        """
        if not (0 <= mask <= 255):
            raise ValueError("mask doit Ãªtre entre 0 et 255")
        self._tx(bytes([OP_SEND_TRIGGER_MASK, mask]))

    def send_trigger_on_line(self, line: int) -> None:
        """
        GÃ©nÃ¨re un trigger sur une seule ligne (numÃ©ro entre 0 et 7).

        Exemple :
        >>> dev.send_trigger_on_line(3)  # active la ligne 3 pendant la durÃ©e dÃ©finie
        """
        if not (0 <= line <= 7):
            raise ValueError("line doit Ãªtre entre 0 et 7")
        self._tx(bytes([OP_SEND_TRIGGER_ON_LINE, line]))

    def set_high_mask(self, mask: int) -> None:
        """
        Passe en HIGH toutes les lignes correspondant aux bits Ã  1 dans le mask.
        (Ã‰tat maintenu indÃ©finiment, pas un trigger.)

        Exemple :
        >>> dev.set_high_mask(0b00000011)  # lignes 0 et 1 passent en HIGH
        """
        if not (0 <= mask <= 255):
            raise ValueError("mask doit Ãªtre entre 0 et 255")
        self._tx(bytes([OP_SET_HIGH_MASK, mask]))

    def set_low_mask(self, mask: int) -> None:
        """
        Passe en LOW toutes les lignes correspondant aux bits Ã  1 dans le mask.

        Exemple :
        >>> dev.set_low_mask(0b00001111)  # force les 4 premiÃ¨res lignes Ã  LOW
        """
        if not (0 <= mask <= 255):
            raise ValueError("mask doit Ãªtre entre 0 et 255")
        self._tx(bytes([OP_SET_LOW_MASK, mask]))

    def set_high_on_line(self, line: int) -> None:
        """Passe une seule ligne (0â€“7) en HIGH, de maniÃ¨re persistante."""
        if not (0 <= line <= 7):
            raise ValueError("line doit Ãªtre entre 0 et 7")
        self._tx(bytes([OP_SET_HIGH_ON_LINE, line]))

    def set_low_on_line(self, line: int) -> None:
        """Passe une seule ligne (0â€“7) en LOW, de maniÃ¨re persistante."""
        if not (0 <= line <= 7):
            raise ValueError("la ligne doit Ãªtre entre 0 et 7")
        self._tx(bytes([OP_SET_LOW_ON_LINE, line]))

    def get_response_button_mask(self) -> int:
        """
        Lit lâ€™Ã©tat des boutons du boÃ®tier de rÃ©ponse.

        Retour :
        - entier (mask 0â€“255) dont les bits Ã  1 indiquent les boutons pressÃ©s.
        - exemple : 0b00000100 signifie que le bouton 2 est appuyÃ©.

        Exemple :
        >>> mask = dev.get_response_button_mask()
        >>> print(bin(mask))
        """
        self._tx(bytes([OP_GET_RESPONSE_BUTTON]))
        resp = self._rx_exact(1)
        return resp[0]

    def decode_forp(self, mask: int) -> List[str]:
        """
        Traduit le mask renvoyÃ© par `get_response_button_mask()` en texte lisible.

        Argument :
        - mask : entier entre 0 et 255

        Retour :
        - liste de chaÃ®nes correspondant aux boutons activÃ©s

        Exemple :
        >>> mask = dev.get_response_button_mask()
        >>> dev.decode_forp(mask)
        ['bouton rouge droit activÃ©', 'bouton bleu gauche activÃ©']
        """
        if not (0 <= mask <= 255):
            raise ValueError("mask doit Ãªtre entre 0 et 255")
        msgs: List[str] = []
        for bit in range(8):
            if (mask >> bit) & 1:
                label = self.forp_map.get(bit, f"ligne {bit} activÃ©e")
                msgs.append(label)
        return msgs
